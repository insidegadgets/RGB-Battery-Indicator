   1               		.file	"main.c"
   2               	__SP_L__ = 0x3d
   3               	__SREG__ = 0x3f
   4               	__tmp_reg__ = 0
   5               	__zero_reg__ = 1
   6               		.text
   7               	.Ltext0:
   8               		.cfi_sections	.debug_frame
   9               	.global	system_sleep
  11               	system_sleep:
  12               	.LFB8:
  13               		.file 1 "setup.c"
   1:setup.c       **** /*
   2:setup.c       ****  RGB Battery Indicator
   3:setup.c       ****  Version: 1.0
   4:setup.c       ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   5:setup.c       ****  Created: 14/05/2020
   6:setup.c       ****  Last Modified: 14/05/2020
   7:setup.c       **** 
   8:setup.c       ****  */
   9:setup.c       **** 
  10:setup.c       **** #ifndef cbi
  11:setup.c       **** #define cbi(sfr, bit) (_SFR_BYTE(sfr) &= ~_BV(bit))
  12:setup.c       **** #endif
  13:setup.c       **** #ifndef sbi
  14:setup.c       **** #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
  15:setup.c       **** #endif
  16:setup.c       **** 
  17:setup.c       **** #ifndef NULL
  18:setup.c       **** #define NULL ((void *)0)
  19:setup.c       **** #endif
  20:setup.c       **** 
  21:setup.c       **** #define LOW 0
  22:setup.c       **** #define HIGH 1
  23:setup.c       **** #define false 0
  24:setup.c       **** #define true 1
  25:setup.c       **** 
  26:setup.c       **** // Watchdog timeouts to values
  27:setup.c       **** #define T16MS 0
  28:setup.c       **** #define T32MS 1
  29:setup.c       **** #define T64MS 2
  30:setup.c       **** #define T128MS 3
  31:setup.c       **** #define T250MS 4
  32:setup.c       **** #define T500MS 5
  33:setup.c       **** #define T1S 6
  34:setup.c       **** #define T2S 7
  35:setup.c       **** #define T4S 8
  36:setup.c       **** #define T8S 9
  37:setup.c       **** 
  38:setup.c       **** #define ADC_REF_VCC 0
  39:setup.c       **** #define ADC_REF_1_1V 1
  40:setup.c       **** 
  41:setup.c       **** #define batteryADCPin 3
  42:setup.c       **** 
  43:setup.c       **** #define RGB_RED PB0
  44:setup.c       **** #define RGB_GREEN PB1
  45:setup.c       **** #define RGB_BLUE PB2
  46:setup.c       **** 
  47:setup.c       **** // Put the AVR in power down sleep mode
  48:setup.c       **** void system_sleep(void) {
  14               		.loc 1 48 0
  15               		.cfi_startproc
  16               	/* prologue: function */
  17               	/* frame size = 0 */
  18               	/* stack size = 0 */
  19               	.L__stack_usage = 0
  49:setup.c       **** 	set_sleep_mode(SLEEP_MODE_PWR_DOWN); // Set sleep mode
  20               		.loc 1 49 0
  21 0000 85B7      		in r24,0x35
  22 0002 877E      		andi r24,lo8(-25)
  23 0004 8061      		ori r24,lo8(16)
  24 0006 85BF      		out 0x35,r24
  50:setup.c       **** 	sleep_mode(); // System sleeps here
  25               		.loc 1 50 0
  26 0008 85B7      		in r24,0x35
  27 000a 8062      		ori r24,lo8(32)
  28 000c 85BF      		out 0x35,r24
  29               	/* #APP */
  30               	 ;  50 "setup.c" 1
  31 000e 8895      		sleep
  32               		
  33               	 ;  0 "" 2
  34               	/* #NOAPP */
  35 0010 85B7      		in r24,0x35
  36 0012 8F7D      		andi r24,lo8(-33)
  37 0014 85BF      		out 0x35,r24
  38 0016 0895      		ret
  39               		.cfi_endproc
  40               	.LFE8:
  42               	.global	setup_watchdog
  44               	setup_watchdog:
  45               	.LFB9:
  51:setup.c       **** }
  52:setup.c       **** 
  53:setup.c       **** // Setup watchdog timed sequence
  54:setup.c       **** void setup_watchdog(uint8_t wdDelay) {
  46               		.loc 1 54 0
  47               		.cfi_startproc
  48               	.LVL0:
  49               	/* prologue: function */
  50               	/* frame size = 0 */
  51               	/* stack size = 0 */
  52               	.L__stack_usage = 0
  55:setup.c       **** 	if (wdDelay > 7) {
  53               		.loc 1 55 0
  54 0018 8830      		cpi r24,lo8(8)
  55 001a 00F0      		brlo .L3
  56:setup.c       **** 		wdDelay = wdDelay & 7;
  56               		.loc 1 56 0
  57 001c 8770      		andi r24,lo8(7)
  58               	.LVL1:
  57:setup.c       **** 		wdDelay |= (1<<5); // Set WDP3 bit
  59               		.loc 1 57 0
  60 001e 8062      		ori r24,lo8(32)
  61               	.LVL2:
  62               	.L3:
  58:setup.c       **** 	}
  59:setup.c       **** 	
  60:setup.c       **** 	MCUSR &= ~(1<<WDRF); // Turn off flag
  63               		.loc 1 60 0
  64 0020 94B7      		in r25,0x34
  65 0022 977F      		andi r25,lo8(-9)
  66 0024 94BF      		out 0x34,r25
  61:setup.c       **** 	WDTCR |= (1<<WDCE) | (1<<WDE); // Start timed sequence
  67               		.loc 1 61 0
  68 0026 91B5      		in r25,0x21
  69 0028 9861      		ori r25,lo8(24)
  70 002a 91BD      		out 0x21,r25
  62:setup.c       **** 	WDTCR = wdDelay | (1<<WDTIE); // Set new watchdog timeout value
  71               		.loc 1 62 0
  72 002c 8064      		ori r24,lo8(64)
  73               	.LVL3:
  74 002e 81BD      		out 0x21,r24
  75 0030 0895      		ret
  76               		.cfi_endproc
  77               	.LFE9:
  79               	.global	turn_off_watchdog
  81               	turn_off_watchdog:
  82               	.LFB10:
  63:setup.c       **** }
  64:setup.c       **** 
  65:setup.c       **** // Turn off the Watchdog
  66:setup.c       **** void turn_off_watchdog(void) {
  83               		.loc 1 66 0
  84               		.cfi_startproc
  85               	/* prologue: function */
  86               	/* frame size = 0 */
  87               	/* stack size = 0 */
  88               	.L__stack_usage = 0
  67:setup.c       **** 	cli(); // Turn interrupts off
  89               		.loc 1 67 0
  90               	/* #APP */
  91               	 ;  67 "setup.c" 1
  92 0032 F894      		cli
  93               	 ;  0 "" 2
  68:setup.c       **** 	MCUSR &= ~(1<<WDRF);
  94               		.loc 1 68 0
  95               	/* #NOAPP */
  96 0034 84B7      		in r24,0x34
  97 0036 877F      		andi r24,lo8(-9)
  98 0038 84BF      		out 0x34,r24
  69:setup.c       **** 	WDTCR |= (1<<WDCE) | (1<<WDE);
  99               		.loc 1 69 0
 100 003a 81B5      		in r24,0x21
 101 003c 8861      		ori r24,lo8(24)
 102 003e 81BD      		out 0x21,r24
  70:setup.c       **** 	WDTCR = 0;
 103               		.loc 1 70 0
 104 0040 11BC      		out 0x21,__zero_reg__
  71:setup.c       **** 	sei(); // Turn interrupts back on
 105               		.loc 1 71 0
 106               	/* #APP */
 107               	 ;  71 "setup.c" 1
 108 0042 7894      		sei
 109               	 ;  0 "" 2
 110               	/* #NOAPP */
 111 0044 0895      		ret
 112               		.cfi_endproc
 113               	.LFE10:
 115               	.global	watchdog_sleep
 117               	watchdog_sleep:
 118               	.LFB11:
  72:setup.c       **** }
  73:setup.c       **** 
  74:setup.c       **** // Watchdog sleep function - setup, sleep and turn off
  75:setup.c       **** void watchdog_sleep(uint8_t timeout) { 
 119               		.loc 1 75 0
 120               		.cfi_startproc
 121               	.LVL4:
 122               	/* prologue: function */
 123               	/* frame size = 0 */
 124               	/* stack size = 0 */
 125               	.L__stack_usage = 0
  76:setup.c       **** 	setup_watchdog(timeout);
 126               		.loc 1 76 0
 127 0046 00D0      		rcall setup_watchdog
 128               	.LVL5:
  77:setup.c       **** 	system_sleep();
 129               		.loc 1 77 0
 130 0048 00D0      		rcall system_sleep
 131               	.LVL6:
  78:setup.c       **** 	turn_off_watchdog();
 132               		.loc 1 78 0
 133 004a 00C0      		rjmp turn_off_watchdog
 134               	.LVL7:
 135               		.cfi_endproc
 136               	.LFE11:
 138               	.global	adc_read
 140               	adc_read:
 141               	.LFB12:
  79:setup.c       **** }
  80:setup.c       **** 
  81:setup.c       **** // ADC Read
  82:setup.c       **** int adc_read(uint8_t pin, uint8_t reference) {
 142               		.loc 1 82 0
 143               		.cfi_startproc
 144               	.LVL8:
 145               	/* prologue: function */
 146               	/* frame size = 0 */
 147               	/* stack size = 0 */
 148               	.L__stack_usage = 0
 149 004c 8F73      		andi r24,lo8(63)
 150               	.LVL9:
  83:setup.c       **** 	uint8_t low, high;
  84:setup.c       **** 	
  85:setup.c       **** 	// Set the pin and ref
  86:setup.c       **** 	if (reference == ADC_REF_1_1V) {
 151               		.loc 1 86 0
 152 004e 6130      		cpi r22,lo8(1)
 153 0050 01F4      		brne .L8
  87:setup.c       **** 		ADMUX = (1<<REFS0) | (pin & 0x3F);
 154               		.loc 1 87 0
 155 0052 8064      		ori r24,lo8(64)
 156               	.L8:
  88:setup.c       **** 	}
  89:setup.c       **** 	else {
  90:setup.c       **** 		ADMUX = (pin & 0x3F);
 157               		.loc 1 90 0
 158 0054 87B9      		out 0x7,r24
  91:setup.c       **** 	}
  92:setup.c       **** 	
  93:setup.c       **** 	set_sleep_mode(SLEEP_MODE_ADC); // Set sleep mode ADC
 159               		.loc 1 93 0
 160 0056 85B7      		in r24,0x35
 161 0058 877E      		andi r24,lo8(-25)
 162 005a 8860      		ori r24,lo8(8)
 163 005c 85BF      		out 0x35,r24
  94:setup.c       **** 	sleep_mode(); // System sleeps here
 164               		.loc 1 94 0
 165 005e 85B7      		in r24,0x35
 166 0060 8062      		ori r24,lo8(32)
 167 0062 85BF      		out 0x35,r24
 168               	/* #APP */
 169               	 ;  94 "setup.c" 1
 170 0064 8895      		sleep
 171               		
 172               	 ;  0 "" 2
 173               	/* #NOAPP */
 174 0066 85B7      		in r24,0x35
 175 0068 8F7D      		andi r24,lo8(-33)
 176 006a 85BF      		out 0x35,r24
  95:setup.c       **** 	
  96:setup.c       **** 	// we have to read ADCL first; doing so locks both ADCL
  97:setup.c       **** 	// and ADCH until ADCH is read.  reading ADCL second would
  98:setup.c       **** 	// cause the results of each conversion to be discarded,
  99:setup.c       **** 	// as ADCL and ADCH would be locked when it completed.
 100:setup.c       **** 	low = ADCL;
 177               		.loc 1 100 0
 178 006c 84B1      		in r24,0x4
 179               	.LVL10:
 101:setup.c       **** 	high = ADCH;
 180               		.loc 1 101 0
 181 006e 25B1      		in r18,0x5
 182               	.LVL11:
 102:setup.c       **** 	
 103:setup.c       **** 	// combine the two bytes
 104:setup.c       **** 	return (high << 8) | low;
 183               		.loc 1 104 0
 184 0070 90E0      		ldi r25,0
 105:setup.c       **** }
 185               		.loc 1 105 0
 186 0072 922B      		or r25,r18
 187 0074 0895      		ret
 188               		.cfi_endproc
 189               	.LFE12:
 191               	.global	setup
 193               	setup:
 194               	.LFB13:
 106:setup.c       **** 
 107:setup.c       **** // Setup the AVR
 108:setup.c       **** void setup(void) {
 195               		.loc 1 108 0
 196               		.cfi_startproc
 197               	/* prologue: function */
 198               	/* frame size = 0 */
 199               	/* stack size = 0 */
 200               	.L__stack_usage = 0
 109:setup.c       **** 	// Set RGB outputs and all off
 110:setup.c       **** 	DDRB |= (1<<PB2) | (1<<PB1) | (1<<PB0);
 201               		.loc 1 110 0
 202 0076 87B3      		in r24,0x17
 203 0078 8760      		ori r24,lo8(7)
 204 007a 87BB      		out 0x17,r24
 111:setup.c       **** 	PORTB |= (1<<PB2) | (1<<PB1) | (1<<PB0);
 205               		.loc 1 111 0
 206 007c 88B3      		in r24,0x18
 207 007e 8760      		ori r24,lo8(7)
 208 0080 88BB      		out 0x18,r24
 209               	.LVL12:
 210               	.LBB8:
 211               	.LBB9:
 212               		.file 2 "c:\\winavr-20100110\\avr\\include\\util\\delay.h"
   1:c:\winavr-20100110\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\winavr-20100110\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\winavr-20100110\avr\include\util\delay.h ****    All rights reserved.
   5:c:\winavr-20100110\avr\include\util\delay.h **** 
   6:c:\winavr-20100110\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\winavr-20100110\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\winavr-20100110\avr\include\util\delay.h **** 
   9:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\winavr-20100110\avr\include\util\delay.h **** 
  12:c:\winavr-20100110\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\winavr-20100110\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\winavr-20100110\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\winavr-20100110\avr\include\util\delay.h ****      distribution.
  16:c:\winavr-20100110\avr\include\util\delay.h **** 
  17:c:\winavr-20100110\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\winavr-20100110\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\winavr-20100110\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\winavr-20100110\avr\include\util\delay.h **** 
  21:c:\winavr-20100110\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\winavr-20100110\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\winavr-20100110\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\winavr-20100110\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\winavr-20100110\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\winavr-20100110\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\winavr-20100110\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\winavr-20100110\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\winavr-20100110\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\winavr-20100110\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\winavr-20100110\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\winavr-20100110\avr\include\util\delay.h **** 
  33:c:\winavr-20100110\avr\include\util\delay.h **** /* $Id$ */
  34:c:\winavr-20100110\avr\include\util\delay.h **** 
  35:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\winavr-20100110\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\winavr-20100110\avr\include\util\delay.h **** 
  38:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\winavr-20100110\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\winavr-20100110\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\winavr-20100110\avr\include\util\delay.h **** #  endif
  42:c:\winavr-20100110\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\winavr-20100110\avr\include\util\delay.h **** 
  44:c:\winavr-20100110\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\winavr-20100110\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\winavr-20100110\avr\include\util\delay.h **** #include <math.h>
  47:c:\winavr-20100110\avr\include\util\delay.h **** 
  48:c:\winavr-20100110\avr\include\util\delay.h **** /** \file */
  49:c:\winavr-20100110\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\winavr-20100110\avr\include\util\delay.h ****     \code
  51:c:\winavr-20100110\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\winavr-20100110\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\winavr-20100110\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\winavr-20100110\avr\include\util\delay.h ****     \endcode
  55:c:\winavr-20100110\avr\include\util\delay.h **** 
  56:c:\winavr-20100110\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\winavr-20100110\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\winavr-20100110\avr\include\util\delay.h ****     used.
  60:c:\winavr-20100110\avr\include\util\delay.h **** 
  61:c:\winavr-20100110\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\winavr-20100110\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\winavr-20100110\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\winavr-20100110\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\winavr-20100110\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\winavr-20100110\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\winavr-20100110\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\winavr-20100110\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\winavr-20100110\avr\include\util\delay.h **** 
  70:c:\winavr-20100110\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\winavr-20100110\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\winavr-20100110\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\winavr-20100110\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\winavr-20100110\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\winavr-20100110\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\winavr-20100110\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\winavr-20100110\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\winavr-20100110\avr\include\util\delay.h **** 
  79:c:\winavr-20100110\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\winavr-20100110\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\winavr-20100110\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\winavr-20100110\avr\include\util\delay.h **** 
  83:c:\winavr-20100110\avr\include\util\delay.h **** */
  84:c:\winavr-20100110\avr\include\util\delay.h **** 
  85:c:\winavr-20100110\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\winavr-20100110\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\winavr-20100110\avr\include\util\delay.h **** #endif
  89:c:\winavr-20100110\avr\include\util\delay.h **** 
  90:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\winavr-20100110\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\winavr-20100110\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\winavr-20100110\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\winavr-20100110\avr\include\util\delay.h ****     \def F_CPU
  95:c:\winavr-20100110\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\winavr-20100110\avr\include\util\delay.h **** 
  97:c:\winavr-20100110\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\winavr-20100110\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\winavr-20100110\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\winavr-20100110\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\winavr-20100110\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\winavr-20100110\avr\include\util\delay.h **** 
 103:c:\winavr-20100110\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\winavr-20100110\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\winavr-20100110\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\winavr-20100110\avr\include\util\delay.h ****     integer value.
 107:c:\winavr-20100110\avr\include\util\delay.h ****  */
 108:c:\winavr-20100110\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 110:c:\winavr-20100110\avr\include\util\delay.h **** 
 111:c:\winavr-20100110\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\winavr-20100110\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 114:c:\winavr-20100110\avr\include\util\delay.h **** 
 115:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\winavr-20100110\avr\include\util\delay.h **** #  include <math.h>
 119:c:\winavr-20100110\avr\include\util\delay.h **** #endif
 120:c:\winavr-20100110\avr\include\util\delay.h **** 
 121:c:\winavr-20100110\avr\include\util\delay.h **** /**
 122:c:\winavr-20100110\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\winavr-20100110\avr\include\util\delay.h **** 
 124:c:\winavr-20100110\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\winavr-20100110\avr\include\util\delay.h **** 
 126:c:\winavr-20100110\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\winavr-20100110\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\winavr-20100110\avr\include\util\delay.h **** 
 129:c:\winavr-20100110\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\winavr-20100110\avr\include\util\delay.h **** 
 131:c:\winavr-20100110\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\winavr-20100110\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\winavr-20100110\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\winavr-20100110\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\winavr-20100110\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\winavr-20100110\avr\include\util\delay.h **** 
 137:c:\winavr-20100110\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\winavr-20100110\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\winavr-20100110\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\winavr-20100110\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\winavr-20100110\avr\include\util\delay.h **** 
 142:c:\winavr-20100110\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\winavr-20100110\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\winavr-20100110\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\winavr-20100110\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\winavr-20100110\avr\include\util\delay.h **** 
 147:c:\winavr-20100110\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\winavr-20100110\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\winavr-20100110\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\winavr-20100110\avr\include\util\delay.h ****    respectively.
 151:c:\winavr-20100110\avr\include\util\delay.h **** 
 152:c:\winavr-20100110\avr\include\util\delay.h ****    \note
 153:c:\winavr-20100110\avr\include\util\delay.h **** 
 154:c:\winavr-20100110\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\winavr-20100110\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\winavr-20100110\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\winavr-20100110\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\winavr-20100110\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\winavr-20100110\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\winavr-20100110\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\winavr-20100110\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\winavr-20100110\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\winavr-20100110\avr\include\util\delay.h **** 
 164:c:\winavr-20100110\avr\include\util\delay.h ****  */
 165:c:\winavr-20100110\avr\include\util\delay.h **** void
 166:c:\winavr-20100110\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\winavr-20100110\avr\include\util\delay.h **** {
 168:c:\winavr-20100110\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\winavr-20100110\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\winavr-20100110\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\winavr-20100110\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\winavr-20100110\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\winavr-20100110\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\winavr-20100110\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\winavr-20100110\avr\include\util\delay.h **** 
 176:c:\winavr-20100110\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\winavr-20100110\avr\include\util\delay.h **** 
 179:c:\winavr-20100110\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\winavr-20100110\avr\include\util\delay.h **** 
 182:c:\winavr-20100110\avr\include\util\delay.h **** 	#else
 183:c:\winavr-20100110\avr\include\util\delay.h **** 		//round up by default
 184:c:\winavr-20100110\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\winavr-20100110\avr\include\util\delay.h **** 	#endif
 186:c:\winavr-20100110\avr\include\util\delay.h **** 
 187:c:\winavr-20100110\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 213               		.loc 2 187 0
 214 0082 83E2      		ldi r24,lo8(-3037)
 215 0084 94EF      		ldi r25,hi8(-3037)
 216 0086 0197      	1:	sbiw r24,1
 217 0088 01F4      		brne 1b
 218 008a 00C0      		rjmp .
 219 008c 0000      		nop
 220               	.LVL13:
 221               	.LBE9:
 222               	.LBE8:
 112:setup.c       **** 	
 113:setup.c       **** 	// Wait a bit
 114:setup.c       **** 	_delay_ms(250);
 115:setup.c       **** 	
 116:setup.c       **** 	// Set ADC prescale factor to 8
 117:setup.c       **** 	// 1 MHz / 8 = 125 KHz, inside the desired 50-200 KHz range.
 118:setup.c       **** 	sbi(ADCSRA, ADPS1);
 223               		.loc 1 118 0
 224 008e 319A      		sbi 0x6,1
 119:setup.c       **** 	sbi(ADCSRA, ADPS0);
 225               		.loc 1 119 0
 226 0090 309A      		sbi 0x6,0
 120:setup.c       **** 	
 121:setup.c       **** 	// Enable ADC/interrupt
 122:setup.c       **** 	sbi(ADCSRA, ADEN);
 227               		.loc 1 122 0
 228 0092 379A      		sbi 0x6,7
 123:setup.c       **** 	sbi(ADCSRA, ADIE);
 229               		.loc 1 123 0
 230 0094 339A      		sbi 0x6,3
 124:setup.c       **** 	
 125:setup.c       **** 	sei(); // Turn on interrupts
 231               		.loc 1 125 0
 232               	/* #APP */
 233               	 ;  125 "setup.c" 1
 234 0096 7894      		sei
 235               	 ;  0 "" 2
 236               	/* #NOAPP */
 237 0098 0895      		ret
 238               		.cfi_endproc
 239               	.LFE13:
 241               		.section	.text.startup,"ax",@progbits
 242               	.global	main
 244               	main:
 245               	.LFB14:
 246               		.file 3 "main.c"
   1:main.c        **** /*
   2:main.c        ****  RGB Battery Indicator
   3:main.c        ****  Version: 1.0
   4:main.c        ****  Author: Alex from insideGadgets (www.insidegadgets.com)
   5:main.c        ****  Created: 14/05/2020
   6:main.c        ****  Last Modified: 14/05/2020
   7:main.c        ****  
   8:main.c        ****  Suitable for monitoring LiPo batteries
   9:main.c        ****  
  10:main.c        ****  */
  11:main.c        **** 
  12:main.c        **** #define F_CPU 1000000
  13:main.c        **** 
  14:main.c        **** #include <avr/io.h>
  15:main.c        **** #include <avr/wdt.h>
  16:main.c        **** #include <avr/interrupt.h>
  17:main.c        **** #include <avr/sleep.h>
  18:main.c        **** #include <util/delay.h>
  19:main.c        **** #include "setup.c"
  20:main.c        **** 
  21:main.c        **** int main(void) {
 247               		.loc 3 21 0
 248               		.cfi_startproc
 249               	/* prologue: function */
 250               	/* frame size = 0 */
 251               	/* stack size = 0 */
 252               	.L__stack_usage = 0
  22:main.c        **** 	setup();
 253               		.loc 3 22 0
 254 0000 00D0      		rcall setup
 255               	.LVL14:
  23:main.c        **** 	
  24:main.c        **** 	uint8_t rgbColour = 0;
 256               		.loc 3 24 0
 257 0002 C0E0      		ldi r28,0
 258               	.LBB10:
  25:main.c        **** 	
  26:main.c        **** 	while (1) {
  27:main.c        **** 		// 5 samples over 25ms
  28:main.c        **** 		uint16_t batteryVoltageLevel = 0;
  29:main.c        **** 		for (uint8_t x = 0; x < 5; x++) {
  30:main.c        **** 			batteryVoltageLevel += adc_read(batteryADCPin, ADC_REF_1_1V);
  31:main.c        **** 			_delay_ms(5);
  32:main.c        **** 		}
  33:main.c        **** 		batteryVoltageLevel = batteryVoltageLevel / 5;
 259               		.loc 3 33 0
 260 0004 05E0      		ldi r16,lo8(5)
 261 0006 10E0      		ldi r17,0
 262               	.LVL15:
 263               	.L17:
 264               	.LBE10:
  24:main.c        **** 	
 265               		.loc 3 24 0
 266 0008 D5E0      		ldi r29,lo8(5)
 267               	.LBB14:
  28:main.c        **** 		for (uint8_t x = 0; x < 5; x++) {
 268               		.loc 3 28 0
 269 000a E12C      		mov r14,__zero_reg__
 270 000c F12C      		mov r15,__zero_reg__
 271               	.LVL16:
 272               	.L12:
 273               	.LBB11:
  30:main.c        **** 			_delay_ms(5);
 274               		.loc 3 30 0 discriminator 3
 275 000e 61E0      		ldi r22,lo8(1)
 276 0010 83E0      		ldi r24,lo8(3)
 277 0012 00D0      		rcall adc_read
 278               	.LVL17:
 279 0014 E80E      		add r14,r24
 280 0016 F91E      		adc r15,r25
 281               	.LVL18:
 282               	.LBB12:
 283               	.LBB13:
 284               		.loc 2 187 0 discriminator 3
 285 0018 81EE      		ldi r24,lo8(1249)
 286 001a 94E0      		ldi r25,hi8(1249)
 287 001c 0197      	1:	sbiw r24,1
 288 001e 01F4      		brne 1b
 289 0020 00C0      		rjmp .
 290 0022 0000      		nop
 291               	.LVL19:
 292 0024 D150      		subi r29,lo8(-(-1))
 293               	.LVL20:
 294               	.LBE13:
 295               	.LBE12:
  29:main.c        **** 			batteryVoltageLevel += adc_read(batteryADCPin, ADC_REF_1_1V);
 296               		.loc 3 29 0 discriminator 3
 297 0026 01F4      		brne .L12
 298               	.LBE11:
 299               		.loc 3 33 0
 300 0028 C701      		movw r24,r14
 301 002a B801      		movw r22,r16
 302 002c 00D0      		rcall __udivmodhi4
 303               	.LVL21:
  34:main.c        **** 		
  35:main.c        **** 		
  36:main.c        **** 		int greenHysterious = 0;
  37:main.c        **** 		int blueHysterious = 0;
  38:main.c        **** 		if (rgbColour == 2) { // Green
 304               		.loc 3 38 0
 305 002e C230      		cpi r28,lo8(2)
 306 0030 01F0      		breq .L18
  39:main.c        **** 			greenHysterious = -10;
  40:main.c        **** 		}
  41:main.c        **** 		else if (rgbColour == 1) { // Blue
 307               		.loc 3 41 0
 308 0032 C130      		cpi r28,lo8(1)
 309 0034 01F0      		breq .L19
  42:main.c        **** 			greenHysterious = 10;
  43:main.c        **** 		}
  44:main.c        **** 		else { // Red
  45:main.c        **** 			blueHysterious = 10;
 310               		.loc 3 45 0
 311 0036 8AE0      		ldi r24,lo8(10)
 312 0038 90E0      		ldi r25,0
  36:main.c        **** 		int blueHysterious = 0;
 313               		.loc 3 36 0
 314 003a 20E0      		ldi r18,0
 315 003c 30E0      		ldi r19,0
 316 003e 00C0      		rjmp .L13
 317               	.L18:
  37:main.c        **** 		if (rgbColour == 2) { // Green
 318               		.loc 3 37 0
 319 0040 80E0      		ldi r24,0
 320 0042 90E0      		ldi r25,0
  39:main.c        **** 		}
 321               		.loc 3 39 0
 322 0044 26EF      		ldi r18,lo8(-10)
 323 0046 3FEF      		ldi r19,lo8(-1)
 324 0048 00C0      		rjmp .L13
 325               	.L19:
  37:main.c        **** 		if (rgbColour == 2) { // Green
 326               		.loc 3 37 0
 327 004a 80E0      		ldi r24,0
 328 004c 90E0      		ldi r25,0
  42:main.c        **** 		}
 329               		.loc 3 42 0
 330 004e 2AE0      		ldi r18,lo8(10)
 331 0050 30E0      		ldi r19,0
 332               	.L13:
 333               	.LVL22:
  46:main.c        **** 		}
  47:main.c        **** 		
  48:main.c        **** 		
  49:main.c        **** 		// Green
  50:main.c        **** 		if (batteryVoltageLevel >= (650 + greenHysterious)) { // 3.8v
 334               		.loc 3 50 0
 335 0052 2657      		subi r18,118
 336 0054 3D4F      		sbci r19,-3
 337               	.LVL23:
 338 0056 6217      		cp r22,r18
 339 0058 7307      		cpc r23,r19
 340 005a 00F0      		brlo .L14
  51:main.c        **** 			PORTB &= ~(1<<RGB_GREEN);
 341               		.loc 3 51 0
 342 005c C198      		cbi 0x18,1
  52:main.c        **** 			PORTB |= (1<<RGB_RED);
 343               		.loc 3 52 0
 344 005e C09A      		sbi 0x18,0
  53:main.c        **** 			PORTB |= (1<<RGB_BLUE);
 345               		.loc 3 53 0
 346 0060 C29A      		sbi 0x18,2
 347               	.LVL24:
  54:main.c        **** 			rgbColour = 2;
 348               		.loc 3 54 0
 349 0062 C2E0      		ldi r28,lo8(2)
 350 0064 00C0      		rjmp .L15
 351               	.LVL25:
 352               	.L14:
  55:main.c        **** 		}
  56:main.c        **** 		
  57:main.c        **** 		// Blue
  58:main.c        **** 		else if (batteryVoltageLevel >= (580 + blueHysterious)) { // 3.3v
 353               		.loc 3 58 0
 354 0066 8C5B      		subi r24,-68
 355 0068 9D4F      		sbci r25,-3
 356               	.LVL26:
 357 006a 6817      		cp r22,r24
 358 006c 7907      		cpc r23,r25
 359 006e 00F0      		brlo .L16
  59:main.c        **** 			PORTB &= ~(1<<RGB_BLUE);
 360               		.loc 3 59 0
 361 0070 C298      		cbi 0x18,2
  60:main.c        **** 			PORTB |= (1<<RGB_RED);
 362               		.loc 3 60 0
 363 0072 C09A      		sbi 0x18,0
  61:main.c        **** 			PORTB |= (1<<RGB_GREEN);
 364               		.loc 3 61 0
 365 0074 C19A      		sbi 0x18,1
 366               	.LVL27:
  62:main.c        **** 			rgbColour = 1;
 367               		.loc 3 62 0
 368 0076 C1E0      		ldi r28,lo8(1)
 369 0078 00C0      		rjmp .L15
 370               	.LVL28:
 371               	.L16:
  63:main.c        **** 		}
  64:main.c        **** 		
  65:main.c        **** 		// Red
  66:main.c        **** 		else {
  67:main.c        **** 			PORTB &= ~(1<<RGB_RED);
 372               		.loc 3 67 0
 373 007a C098      		cbi 0x18,0
  68:main.c        **** 			PORTB |= (1<<RGB_BLUE);
 374               		.loc 3 68 0
 375 007c C29A      		sbi 0x18,2
  69:main.c        **** 			PORTB |= (1<<RGB_GREEN);
 376               		.loc 3 69 0
 377 007e C19A      		sbi 0x18,1
 378               	.LVL29:
  70:main.c        **** 			rgbColour = 0;
 379               		.loc 3 70 0
 380 0080 C0E0      		ldi r28,0
 381               	.LVL30:
 382               	.L15:
  71:main.c        **** 		}
  72:main.c        **** 		
  73:main.c        **** 		watchdog_sleep(T1S);
 383               		.loc 3 73 0
 384 0082 86E0      		ldi r24,lo8(6)
 385 0084 00D0      		rcall watchdog_sleep
 386               	.LVL31:
 387               	.LBE14:
  74:main.c        **** 	}
 388               		.loc 3 74 0
 389 0086 00C0      		rjmp .L17
 390               		.cfi_endproc
 391               	.LFE14:
 393               		.text
 394               	.global	__vector_9
 396               	__vector_9:
 397               	.LFB15:
  75:main.c        **** 	
  76:main.c        **** 	
  77:main.c        **** 	return 0;
  78:main.c        **** }
  79:main.c        **** 
  80:main.c        **** EMPTY_INTERRUPT(ADC_vect);
 398               		.loc 3 80 0
 399               		.cfi_startproc
 400               	/* prologue: naked */
 401               	/* frame size = 0 */
 402               	/* stack size = 0 */
 403               	.L__stack_usage = 0
 404               		.loc 3 80 0
 405               	/* #APP */
 406               	 ;  80 "main.c" 1
 407 009a 1895      		reti
 408               	 ;  0 "" 2
 409               	/* epilogue start */
 410               	/* #NOAPP */
 411               		.cfi_endproc
 412               	.LFE15:
 414               	.global	__vector_8
 416               	__vector_8:
 417               	.LFB16:
  81:main.c        **** EMPTY_INTERRUPT(WDT_vect);
 418               		.loc 3 81 0
 419               		.cfi_startproc
 420               	/* prologue: naked */
 421               	/* frame size = 0 */
 422               	/* stack size = 0 */
 423               	.L__stack_usage = 0
 424               		.loc 3 81 0
 425               	/* #APP */
 426               	 ;  81 "main.c" 1
 427 009c 1895      		reti
 428               	 ;  0 "" 2
 429               	/* epilogue start */
 430               	/* #NOAPP */
 431               		.cfi_endproc
 432               	.LFE16:
 434               	.Letext0:
 435               		.file 4 "c:\\winavr-20100110\\avr\\include\\stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:2      *ABS*:0000003d __SP_L__
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:3      *ABS*:0000003f __SREG__
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:4      *ABS*:00000000 __tmp_reg__
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:5      *ABS*:00000001 __zero_reg__
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:11     .text:00000000 system_sleep
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:44     .text:00000018 setup_watchdog
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:81     .text:00000032 turn_off_watchdog
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:117    .text:00000046 watchdog_sleep
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:140    .text:0000004c adc_read
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:193    .text:00000076 setup
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:244    .text.startup:00000000 main
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:396    .text:0000009a __vector_9
C:\Users\Alex\AppData\Local\Temp\ccFRnZPl.s:416    .text:0000009c __vector_8

UNDEFINED SYMBOLS
__udivmodhi4
